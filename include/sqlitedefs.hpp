#pragma once

// clang-format off
// generated by _deps/sqlpp23-src/scripts/sqlpp23-ddl2cpp --path-to-ddl testDB.sqlite.DDL.sql --namespace my_project --path-to-header test.hpp

#include <optional>

#include <sqlpp23/core/basic/table.h>
#include <sqlpp23/core/basic/table_columns.h>
#include <sqlpp23/core/name/create_name_tag.h>
#include <sqlpp23/core/type_traits.h>

namespace incom::terminal_plot::config::sqltables {
  struct DefaultScheme_ {
    struct Id {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(id, id);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct SchemeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(scheme_id, schemeId);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(default_scheme, defaultScheme);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               Id,
               SchemeId>;
    using _required_insert_columns = sqlpp::detail::type_set<>;
  };
  using DefaultScheme = ::sqlpp::table_t<DefaultScheme_>;

  struct SchemePalette_ {
    struct SchemeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(scheme_id, schemeId);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct IndexInPalette {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(index_in_palette, indexInPalette);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct Color {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(color, color);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(scheme_palette, schemePalette);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SchemeId,
               IndexInPalette,
               Color>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<SchemePalette_>, SchemeId>,
               sqlpp::column_t<sqlpp::table_t<SchemePalette_>, IndexInPalette>,
               sqlpp::column_t<sqlpp::table_t<SchemePalette_>, Color>>;
  };
  using SchemePalette = ::sqlpp::table_t<SchemePalette_>;

  struct Schemes_ {
    struct SchemeId {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(scheme_id, schemeId);
      using data_type = std::optional<::sqlpp::integral>;
      using has_default = std::true_type;
    };
    struct Name {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(name, name);
      using data_type = ::sqlpp::text;
      using has_default = std::false_type;
    };
    struct FgColor {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(fg_color, fgColor);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct BgColor {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(bg_color, bgColor);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct CursorColor {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(cursor_color, cursorColor);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    struct SelColor {
      SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(sel_color, selColor);
      using data_type = ::sqlpp::integral;
      using has_default = std::false_type;
    };
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(schemes, schemes);
    template<typename T>
    using _table_columns = sqlpp::table_columns<T,
               SchemeId,
               Name,
               FgColor,
               BgColor,
               CursorColor,
               SelColor>;
    using _required_insert_columns = sqlpp::detail::type_set<
               sqlpp::column_t<sqlpp::table_t<Schemes_>, Name>,
               sqlpp::column_t<sqlpp::table_t<Schemes_>, FgColor>,
               sqlpp::column_t<sqlpp::table_t<Schemes_>, BgColor>,
               sqlpp::column_t<sqlpp::table_t<Schemes_>, CursorColor>,
               sqlpp::column_t<sqlpp::table_t<Schemes_>, SelColor>>;
  };
  using Schemes = ::sqlpp::table_t<Schemes_>;

  struct PragmaTableInfo_ {
  // Column definitions
  struct Cid {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(cid, cid);
    using data_type = ::sqlpp::integral;
    using has_default = std::false_type;
  };

  struct Name {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(name, name);
    using data_type = ::sqlpp::text;
    using has_default = std::false_type;
  };

  struct Type {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(type, type);
    using data_type = ::sqlpp::text;
    using has_default = std::false_type;
  };

  struct NotNull {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(notnull, notnull);
    using data_type = ::sqlpp::integral;
    using has_default = std::false_type;
  };

  struct DfltValue {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(dflt_value, dfltValue);
    using data_type = ::sqlpp::text;
    using has_default = std::true_type; // can be NULL / optional
  };

  struct Pk {
    SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(pk, pk);
    using data_type = ::sqlpp::integral;
    using has_default = std::false_type;
  };

  // Table definition
  SQLPP_CREATE_NAME_TAG_FOR_SQL_AND_CPP(pragma_table_info, pragmaTableInfo);

  template <typename T>
  using _table_columns = sqlpp::table_columns<
      T, Cid, Name, Type, NotNull, DfltValue, Pk>;

  using _required_insert_columns = sqlpp::detail::type_set<>;
};
using PragmaTableInfo = sqlpp::table_t<PragmaTableInfo_>;
  
}
